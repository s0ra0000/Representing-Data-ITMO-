package linkedList;

import interfaces.InterfaceList;

public class LinkedList<U extends Comparable<U>> implements InterfaceList<U> {
    private class Node {
        //Вложенный (внутренний) класс Node представляет узел списка.
        // Каждый узел имеет поле data для хранения данных и поле next, указывающее на следующий узел в списке.
        // Конструктор Node создает новый узел с заданными данными.
    }
    //Здесь объявляются приватные поля head, который представляет начало списка.
    private Node head;

    //Конструктор, инициализирующий связный список
    public LinkedList() {
        //Конструктор класса LinkedList инициализирует начальное значение поля head, устанавливая его в null, таким образом, создается пустой список.
    }
    // Метод возвращающий позицию после последнего элемента
    @Override
    public int end() {
        //Если список пуст (head == null), возвращаем 1.
        //Проходим через весь список, подсчитывая количество узлов.
        //Возвращаем количество узлов + 1.
    }
    // Метод вставляющий элемент x по позиции p
    @Override
    public void insert(U x, int p) {
        //Если p меньше 1, выбрасываем исключение о недопустимой позиции.
        //Если p равно 1, делаем новый узел головой списка.
        //В противном случае, проходим по списку до позиции p - 1.
        //Если не можем найти такую позицию (потому что current == null), выбрасываем исключение.
        //Вставляем новый узел после узла на позиции p - 1.
    }
    // Метод возвращающий позицию элемента x в списке
    @Override
    public int locate(U x) {
        //Проходим по списку, ищем узел с данными x.
        //Возвращаем позицию узла или end(), если такого узла нет.
    }
    // Метод возвращающий элемент из списка по позиции
    @Override
    public U retrieve(int p) {
        //Если p меньше 1, выбрасываем исключение.
        //Проходим по списку до позиции p.
        //Если не можем найти такую позицию, выбрасываем исключение.
        //Возвращаем данные из узла на позиции p.
    }
    // Метод удаляющий элемент из списка по позиции
    @Override
    public void delete(int p) {
        //Если p меньше 1 или список пуст, выбрасываем исключение.
        //Если p равно 1, делаем второй узел головой списка.
        //В противном случае, проходим по списку до позиции p - 1.
        //Удаляем следующий узел, установив next для текущего узла как next для следующего узла.
    }
    // Метод возвращает следующую за p позицию в списке
    @Override
    public int next(int p) {
        //Проходим по списку до позиции p.
        //Если узла нет или это последний узел, возрващаем end().
        //Иначе возвращаем p + 1.
    }
    // Метод возвращает предыдущую перед p позицию в списке
    @Override
    public int previous(int p) {
        //Если p меньше или равно 1, выбрасываем исключение.
        //Иначе возвращаем p - 1.
    }
    // Метод делающий список пустым
    @Override
    public void makeNull() {
        //Устанавливаем голову списка в null.
    }
    // Метод возвращает 1-ую позицию в списке
    @Override
    public int first() {
        //Просто возвращаем 1.
    }
    // Метод выводящий список на печать в порядке расположения элементов в списке
    @Override
    public void printList() {
        //Начинаем с головы списка.
        //Проходим по каждому узлу, выводя его данные.
        //В конце вывода списка, печатаем "null".
    }

}
