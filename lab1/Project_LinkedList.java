package linkedList;

import interfaces.InterfaceList;

public class LinkedList<U extends Comparable<U>> implements InterfaceList<U> {
    private class Node {
        //Вложенный (внутренний) класс Node представляет узел списка.
        // Каждый узел имеет поле data для хранения данных и поле next, указывающее на следующий узел в списке.
        // Конструктор Node создает новый узел с заданными данными.
    }
    //Здесь объявляются приватные поля head, который представляет начало списка, и size, который представляет текущий размер списка.
    private Node head;
    private int size = 0;

    //Конструктор, инициализирующий связный список
    public LinkedList() {
        //Конструктор класса LinkedList инициализирует начальное значение поля head, устанавливая его в null, таким образом, создается пустой список.
    }
    // Метод возвращающий позицию после последнего элемента
    @Override
    public int end() {
        //Просто возвращаем значение size + 1.
    }
    // Метод вставляющий элемент x по позиции p
    @Override
    public void insert(U x, int p) {
        //Проверяем, является ли позиция допустимой с помощью isPositionValid(p).
        //Если список пуст (head == null), устанавливаем новый узел как голову списка.
        //Если позиция равна 1, новый узел становится головой, а предыдущая голова становится следующим элементом после нового.
        //Иначе, проходим по списку до позиции p - 1 и вставляем новый узел после найденного узла.
        //Увеличиваем размер списка на 1.
    }
    // Метод возвращающий позицию элемента x в списке
    @Override
    public int locate(U x) {
        //Начинаем с головы списка.
        //Проходим по каждому узлу и проверяем, равны ли данные этого узла значению x.
        //Если находим соответствие, возвращаем текущую позицию.
        //Если не находим, возвращаем значение, полученное из метода end().
    }
    // Метод возвращающий элемент из списка по позиции
    @Override
    public U retrieve(int p) {
        //Проверяем, является ли позиция допустимой с помощью isPositionValid(p).
        //Проходим по списку до позиции p.
        //Возвращаем данные из узла на позиции p.
        //Если позиция не является допустимой, то выбрасываем исключение.
    }
    // Метод удаляющий элемент из списка по позиции
    @Override
    public void delete(int p) {
        //Проверяем, является ли позиция допустимой с помощью isPositionValid(p).
        //Если позиция равна 1, то устанавливаем второй элемент списка как голову.
        //Иначе, проходим по списку до позиции p - 1 и устанавливаем следующий узел для узла p - 1 как узел p + 1, тем самым пропуская узел p.
        //Уменьшаем размер списка на 1.
        //Если позиция не является допустимой, то выбрасываем исключение.
    }
    // Метод возвращает следующую за p позицию в списке
    @Override
    public int next(int p) {
        //Если позиция допустима, возвращаем p + 1.
        //Если нет, выбрасываем исключение
    }
    // Метод возвращает предыдущую перед p позицию в списке
    @Override
    public int previous(int p) {
        //Если позиция допустима, возвращаем p - 1.
        //Если нет, выбрасываем исключение
    }
    // Метод делающий список пустым
    @Override
    public void makeNull() {
        //Устанавливаем голову списка в null.
        //Устанавливаем размер списка в 0.
    }
    // Метод возвращает 1-ую позицию в списке
    @Override
    public int first() {
        //Просто возвращаем 1.
    }
    // Метод выводящий список на печать в порядке расположения элементов в списке
    @Override
    public void printList() {
        //Начинаем с головы списка.
        //Проходим по каждому узлу, выводя его данные.
        //В конце вывода списка, печатаем "null".
    }
    // Вспомогательный метод для проверки допустимости позиции
    private boolean isPositionValid(int p) {
        //Проверяем, что p не меньше, чем first().
        //Проверяем, что p не больше, чем end().
    }

}
